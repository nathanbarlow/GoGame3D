<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Three.js Basic</title>

    <style>
      body {
        margin: 0px;
				overflow: hidden;
      }
			h1 {
				position: absolute;
				color: "black";
			}
      canvas {
        background: green;
      }

    </style>
	</head>
	<body>
    <h1>My First 3D Website</h1>
    <canvas id="myCanvas"></canvas>

    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>

    <script>

			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			var INTERSECTED;

      //RENDERER
      var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
      renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.setClearColor('black');

      //SCENE
      scene = new THREE.Scene();

			//Go Board Group Creation
			var goBoard = new THREE.Group();

      //LIGHTING
      var light = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(light);

      var light1 = new THREE.PointLight(0xffffff, 0.8);
      scene.add(light1);
			light1.position.set(500, 200, -500);

			var light2 = new THREE.PointLight(0xffffff, 0.5);
      scene.add(light2);
			light2.position.set(-500, 200, -500);

			//SKYBOX
			var textureCube = new THREE.CubeTextureLoader()
					.setPath( 'skybox/')
					.load( [ 'morning_ft.jpg', 'morning_bk.jpg', 'morning_up.jpg', 'morning_dn.jpg', 'morning_rt.jpg', 'morning_lf.jpg' ] );
			scene.background = textureCube;

      //CAMERA
      camera = new THREE.PerspectiveCamera( 45.0, window.innerWidth / window.innerHeight, 0.1, 10000 );
      camera.position.set( 0, 0, 600 );

      //MOVEMENT CONTROLS
      var controls = new THREE.OrbitControls( camera );
      controls.target.set( 0, -200, -500 );
      controls.update();

      //CUBE
      var geometry = new THREE.BoxGeometry(100, 100, 100);
      var material = new THREE.MeshPhongMaterial({
				color: 0xF3FFE2,
				map: new THREE.TextureLoader().load('marbel.jpg'),
				normalMap: new THREE.TextureLoader().load('marbel.jpg'),
				specular: 'red'
			});
      var mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(-75, 0, -500);
			goBoard.add( mesh );

      //GO BOARD BASE
			var boardZ = 500;
			var boardX = boardZ;
			var boardY = 100;
      var boardGeometry = new THREE.BoxGeometry(boardX, boardY, boardZ);
      var boardMaterial = new THREE.MeshLambertMaterial({
				color: 0xffffff,
				envMap: textureCube,
				combine: THREE.MixOperation,
				reflectivity: 0.4,
				map: new THREE.TextureLoader().load('marbel.jpg'),
				//bumpMap: new THREE.TextureLoader().load('marbel.jpg'),
				//bumpScale: 1,
			});
      var boardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
      boardMesh.position.set(0, -200 - boardY / 2, -500);
			goBoard.add( boardMesh );


			//GO BOARD LINES
			var goLines = new THREE.Group();
			var rows = 19; //ADJUST
			var columns = rows;
			var lineWidth = 1; //ADJUST
			var lineLengthLong = 450; //ADJUST
			var lineSpacing = (lineLengthLong - lineWidth) / (rows - 1);
			var lineLengthShort = lineSpacing - lineWidth;
			var lineStartX = -225; //ADJUST
			var lineStartY = -199; //ADJUST
			var lineStartZ = -725; //ADJUST
			var lineX;
			var lineY;
			var lineZ;

			//lines material
			var materialLine = new THREE.MeshStandardMaterial({
				color: 0x000000,
				roughness: 0.8,
				metalness: 0.01
			});

			//create lines
			for ( var c = 0; c < columns; c++ ) {
				//add long lines
				//add geometry
				var geometryLine = new THREE.PlaneGeometry(lineWidth, lineLengthLong);

				//add mesh
				var meshLine = new THREE.Mesh(geometryLine, materialLine);

				//rotate plan flat
				meshLine.rotation.x = degToRad(-90);

				//position mesh
				lineX = lineStartX + lineWidth / 2 + lineSpacing * c;
				lineY = lineStartY;
				lineZ = lineStartZ + lineLengthLong / 2;
				meshLine.position.set(lineX, lineY, lineZ);

				//add mesh to goLines group
				goLines.add(meshLine);

				//ADD SHORT LINES
				//only short lines if this is not the last line
				if (c < columns - 1) {
					for ( var r = 0; r < rows; r++ ) {
						//add geometry
						var geometryLine = new THREE.PlaneGeometry(lineLengthShort, lineWidth);

						//add mesh
						var meshLine = new THREE.Mesh(geometryLine, materialLine);

						//rotate plan flat
						meshLine.rotation.x = degToRad(-90);

						//position mesh
						lineX = lineStartX + lineLengthShort / 2 + lineWidth + lineSpacing * c;
						lineY = lineStartY;
						lineZ = lineStartZ + lineWidth / 2 + lineSpacing * r;
						meshLine.position.set(lineX, lineY, lineZ);

						//add mesh to goLines group
						goLines.add(meshLine);
					}
				};
			}

			//add goLines to scene
			scene.add(goLines);

			//SPHERE
      var geometry3 = new THREE.SphereGeometry(50, 20, 20);
      var material3 = new THREE.MeshStandardMaterial({
				color: 0xF3FFE2,
				map: new THREE.TextureLoader().load('marbel.jpg'),
				//roughness: 0.3,
				//metalness: 0.01
				roughness: 0.3,
				metalness: 0.01
			});
      var mesh3 = new THREE.Mesh(geometry3, boardMaterial);
      mesh3.position.set(75, 0, -500);
			goBoard.add( mesh3 );


			//DEFINE GAME PIECE
      var geometryPiece = new THREE.SphereGeometry(lineSpacing / 2, 20, 20);
			geometryPiece.scale(1, 0.3, 1);
      var materialPiece = new THREE.MeshStandardMaterial({
				color: 0x000000,
				map: new THREE.TextureLoader().load('marbel.jpg'),
				roughness: 0.3,
				metalness: 0.01
			});
      var meshPiece = new THREE.Mesh(geometryPiece, materialPiece);
      meshPiece.position.set(75, -199 + 0.3 * (lineSpacing / 2), -500);
			scene.add(meshPiece);

			//TEST HIGHLIGHT
			var selectorGroup = new THREE.Group();

      var geometryHighlight = new THREE.CircleGeometry(lineSpacing / 2, 20);
      var materialHighlight = new THREE.MeshLambertMaterial({
				color: 0xFF99FFF,

			});
      var meshHighlight = new THREE.Mesh(geometryHighlight, materialHighlight);
      meshHighlight.position.set(75, -199, -475);
			meshHighlight.rotation.x = degToRad(-90);
			selectorGroup.add( meshHighlight );
			meshHighlight.visible = false;

			//Add GoBoard
			scene.add(goBoard);
			scene.add(selectorGroup);

			//SHADOWS
			/*
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFShadowMap;

			var light3 = new THREE.SpotLight(0xFFFFFF, 4.0, 3000);
			light3.position.y = 200;
			light.target = mesh;
			*/


			//ADD EVENT LISTENER
			window.addEventListener( 'mousemove', onMouseMove, false );

      //RENDER LOOP
      requestAnimationFrame(render);

			function addPiece (column, row) {
				//TODO: write code to add a piece to the board.

			}

      function render() {
        mesh.rotation.x += 0.002;
        mesh.rotation.y += 0.002;

				// update the picking ray with the camera and mouse position
				raycaster.setFromCamera( mouse, camera );

				// calculate objects intersecting the picking ray
				var intersects = raycaster.intersectObjects( selectorGroup.children );

				if ( intersects.length > 0 ) { //if objects are hovered over then do this

					if ( INTERSECTED != intersects[ 0 ].object ) { //make INTERSECTED isn't already asigned to this object

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex ); //Do if intersected not equal to null

						INTERSECTED = intersects[ 0 ].object; //set INTERSECTED to first object pointed at
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex(); //used to hold value of moused over object
						INTERSECTED.material.emissive.setHex( 0x262626); //temporairily set value to this.

					}

				} else { //if nothing hovered over set INTERSECTED to null

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex ); //used to reassign previous value

					INTERSECTED = null;

				}

				renderer.render(scene, camera);
        requestAnimationFrame(render);

      }

      function degToRad (numb) {
        return numb * Math.PI / 180
      }

			function onMouseMove( event ) {

				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

    </script>
  </body>
</html>
